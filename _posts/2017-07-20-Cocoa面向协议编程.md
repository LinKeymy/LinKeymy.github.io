---
layout:     post
title:      Cocoa面向协议编程
subtitle:   在Swift考虑如何使用面向协议组织代码
date:       2017-07-20
author:     ALin
header-img: img/post-bg-swift.jpg
catalog: true
tags:
    - iOS
    - Swift
---


> 本文首次发布于 [linra](https://github.com/LinKeymy), 作者 [@onevlin](http://onevlin.com/) ,转载请保留原文链接.

# 面向对象编程的困境

假设有如下`Brid`、`Monkey`、`FlyMonkey`、`Ape`、`Human`，5个类

```sw
class Bird {
    func eat() {
        print("i need to eat")
    }
    func fly () {
        print("i can fly in the sky ")
    }
}

class Monkey {
    func  eat() {
        print("i need to eat")
    }
   func climb() {
       print("\(self) climb")
   }
}


class FlyMonkey:Monkey {
  func cooperate() {
        print("\(self) cooperate with flymokeys")
    }
  func fly () {
      print("i can fly in the sky")
  }
}

class  Ape: Monkey {
    func cooperate() {
        print("\(self) cooperate with monkeys")
    }
}

class Humam: Ape {
    func learn() {
        print("\(self) can learn things quickly")
    }
}

```

现在`Ape`和`Human`也想要像`Bird`和`FlyMonkey`一样`fly`，该如何实现?

### 横向关切点

这时，我们迎来了 OOP 的第一个大困境，那就是我们很难在不同继承关系的类里共用代码。这里的问题用“行话”来说叫做“横切关注点” (Cross-Cutting Concerns)

想要解决这个问题，我们有几个方案：

- Copy & Paste

  这是一个比较糟糕的解决方案，但是有些时候有不少人会选择这个方案，特别是在工期很紧，无暇优化的情况下。这诚然可以理解，但是这也是坏代码的开头。我们应该尽量避免这种做法。

- 引入 BaseClass

  在一个将的继承体系 `Bird` 和`Monkey`的 继承体系抽象成一个 `BaseClass` 上添加需要共享的代码活着直接将代码添加到Monkey中。看起来这是一个稍微靠谱的做法，但是如果不断这么做，会让所谓的 `Base` 很快变成垃圾堆。职责不明确，任何东西都能扔进 `Base`，你完全不知道哪些类走了 `Base`，而这个“超级类”对代码的影响也会不可预估。

- 依赖注入

  通过外界传入一个带有 `fly` 的对象，用新的类型来提供这个功能(估计这就是合成吧)。这是一个稍好的方式，但是引入额外的依赖关系，可能也是我们不太愿意看到的。

- 多继承

  当然，Swift 是不支持多继承的。不过如果有多继承的话，我们确实可以从多个父类进行继承，并将 `fly` 添加到合适的地方。有一些语言选择了支持多继承 (比如 C++)，但是它会带来 OOP 中另一个著名的问题：菱形缺陷。

### 菱形缺陷

上面的例子中，如果我们有多继承

![多继承带来的棱型问题](/assets/lengxin.png)

在上面这种拓扑结构中，我们在 `FlyMonkey` 中实现 `fly`，在 `Human` 中也就可以继承并使用它了。看起来很完美，我们避免了重复。但是多继承有一个无法回避的问题，就是两个父类都实现了同样的方法时，子类该怎么办？我们很难确定应该继承哪一个父类的方法,比如`Human`的`eat`和`cooperate`应该继承哪个分类，而且这样就`Human`包含了`Mokey`的两个副本，副本发生了重叠。因为多继承的拓扑结构是一个菱形，所以这个问题又被叫做菱形缺陷 (Diamond Problem)。像是 C++ 这样的语言选择粗暴地将菱形缺陷的问题交给程序员处理，这无疑非常复杂，并且增加了人为错误的可能性。而绝大多数现代语言如Objective-C，比如Ruby，Java等对多继承这个特性避而远之。

### 动态派发安全性

bjective-C 恰如其名，是一门典型的 OOP 语言，同时它继承了 Small Talk 的消息发送机制。这套机制十分灵活，是 OC 的基础思想，但是有时候相对危险。考虑下面的代码：

```ob

@interface OCMonkey : NSObject
- (void)eat;
- (void)climb;

@end

@implementation OCMonkey

- (void)eat {
    NSLog(@"i need to eat");
}
- (void)climb {
    NSLog(@"i can climb");
}

@end

@interface OCFlyMonkey : OCMonkey
- (void)cooperate;
- (void)fly;

@end

@implementation OCFlyMonkey

- (void)cooperate {
    NSLog(@"i cooperate with flymokeys");
}

- (void)fly {
    NSLog(@"i can fly in the sky");
}
@end

@interface TestDy : NSObject
- (void)testDynamic;
- (void)exceptionDynamic;
@end

- (void)testDynamic {
    OCMonkey *ocM = [[OCMonkey alloc] init];
    [ocM eat];
    OCFlyMonkey *ocFm = [[OCFlyMonkey alloc] init];
    [ocFm eat];
    NSArray *array = @[ocM, ocFm];
    for (id obj in array) {
        [obj eat];
    }
}

- (void)exceptionDynamic {
    OCMonkey *ocM = [[OCMonkey alloc] init];
    [ocM eat];
    OCFlyMonkey *ocFm = [[OCFlyMonkey alloc] init];
    [ocFm eat];
    NSString *str = @"just Str";
    
    NSArray *array = @[ocM, ocFm,str];
    for (id obj in array) {
        [obj eat];
    }
}

@end
```

编译依然可以通过，但是显然，程序将在运行时崩溃。Objective-C 是不安全的，编译器默认你知道某个方法确实有实现，这是消息发送的灵活性所必须付出的代价。而在 app 开发看来，用可能的崩溃来换取灵活性，显然这个代价太大了。虽然这不是 OOP 范式的问题，但它确实在 Objective-C 时代给我们带来了切肤之痛。



#### 三大困境

我们可以总结一下 OOP 面临的这几个问题。

- 动态派发安全性
- 横切关注点
- 菱形缺陷

首先，在 OC 中动态派发让我们承担了在运行时才发现错误的风险，这很有可能是发生在上线产品中的错误。其次，横切关注点让我们难以对对象进行完美的建模，代码的重用也会更加糟糕。



# 协议扩展和面向协议编程

### 使用协议解决 OOP 困境

协议并不是什么新东西，也不是 Swift 的发明。在 Java 和 C# 里，它叫做 `Interface`。而 Swift 中的 protocol 将这个概念继承了下来，并发扬光大。让我们定义个简单协议，并尝试着实现这个协议

## 可可看







> 参考
>
> -  [《面向协议编程与 Cocoa 的邂逅 (上)》](https://onevcat.com/2017/04/storyboard-argue/)

