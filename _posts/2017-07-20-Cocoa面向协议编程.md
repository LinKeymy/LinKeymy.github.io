---
layout:     post
title:      Cocoa面向协议编程
subtitle:   在Swift考虑如何使用面向协议组织代码
date:       2017-07-20
author:     ALin
header-img: img/post-bg-swift.jpg
catalog: true
tags:
    - iOS
    - Swift
---


> 本文首次发布于 [linra](https://github.com/LinKeymy), 作者 [@onevlin](http://onevlin.com/) ,转载请保留原文链接.

# 面向对象编程的困境

假设有如下`Brid`、`Monkey`、`FlyMonkey`、`Ape`、`Human`，5个类

```sw
class Bird {
    func eat() {
        print("i need to eat")
    }
    func fly () {
        print("i can fly in the sky ")
    }
}

class Monkey {
    func  eat() {
        print("i need to eat")
    }
   func climb() {
       print("\(self) climb")
   }
}


class FlyMonkey:Monkey {
  func cooperate() {
        print("\(self) cooperate with flymokeys")
    }
  func fly () {
      print("i can fly in the sky")
  }
}

class  Ape: Monkey {
    func cooperate() {
        print("\(self) cooperate with monkeys")
    }
}

class Humam: Ape {
    func learn() {
        print("\(self) can learn things quickly")
    }
}


```

现在`Ape`和`Human`也想要像`Bird`和`FlyMonkey`一样`fly`，该如何实现?

### 横向关切点

这时，我们迎来了 OOP 的第一个大困境，那就是我们很难在不同继承关系的类里共用代码。这里的问题用“行话”来说叫做“横切关注点” (Cross-Cutting Concerns)

想要解决这个问题，我们有几个方案：

- Copy & Paste

  这是一个比较糟糕的解决方案，但是有些时候有不少人会选择这个方案，特别是在工期很紧，无暇优化的情况下。这诚然可以理解，但是这也是坏代码的开头。我们应该尽量避免这种做法。

- 引入 BaseClass

  在一个将的继承体系 `Bird` 和`Monkey`的 继承体系抽象成一个 `BaseClass` 上添加需要共享的代码活着直接将代码添加到Monkey中。看起来这是一个稍微靠谱的做法，但是如果不断这么做，会让所谓的 `Base` 很快变成垃圾堆。职责不明确，任何东西都能扔进 `Base`，你完全不知道哪些类走了 `Base`，而这个“超级类”对代码的影响也会不可预估。

- 依赖注入

  通过外界传入一个带有 `fly` 的对象，用新的类型来提供这个功能(估计这就是合成吧)。这是一个稍好的方式，但是引入额外的依赖关系，可能也是我们不太愿意看到的。

- 多继承

  当然，Swift 是不支持多继承的。不过如果有多继承的话，我们确实可以从多个父类进行继承，并将 `fly` 添加到合适的地方。有一些语言选择了支持多继承 (比如 C++)，但是它会带来 OOP 中另一个著名的问题：菱形缺陷。

### 菱形缺陷

上面的例子中，如果我们有多继承

![多继承带来的棱型问题](/assets/lengxin.png)

> 参考
>
> -  [《面向协议编程与 Cocoa 的邂逅 (上)》](https://onevcat.com/2017/04/storyboard-argue/)

