---
layout: post
title: 深入理解Runloop
subtitle: 
author: JackLin
date: 2017-01-20 11:31:54 +0800
---

#### 先讲个例子
> Runloop的运行模式和洗衣机的运行模式类似，洗衣机在运行的时候只能是一种运行模式下。如果需要换到另外一种模式运行，需要先关闭然后重新开启进入另外的模式。


假设洗衣机有两种运行模式分别为: 1.羊毛衣物  2.纤维衣物  且洗衣机在运行对应模式时去清洗你标记为对应模式的衣服。

假设你当天穿了三件衣服，一件羊毛衫，一件纤维，一件棉质底裤（标记为common的模式）。这样当运行羊毛衣物模式时清洗羊毛衫和底裤，当运行纤维衣物时清洗纤维和棉质底裤。


#### Runloop概述
一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，这个时候就涉及到Runloop了。Runloop是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。Runloop 的管理并不完全自动的。仍然需要设计线程代码在合适的时候启动runloop并正确响应输入事件。Cocoa 和 Core Fundation分别提供了NSRunLoop 和 CFRunLoopRef runloop objects 来帮助配置和管理你线程的runloop。应用程序不需要显式的创建这些对象(runloop objects);每个线程，包括程序的主线程都有与之对应的 runloop object。只有辅助线程才需要显式的运行它的 runloop。在iOS程序中，主线程会自动创建并运行它的runloop，作为一般应用程序启动过程的一部分。苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent():

```oc
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    [self getRunloopOfMainThread];
}

- (void)getRunloopOfMainThread {
    //Cocoa
    NSRunLoop *mainRunLoop = [NSRunLoop mainRunLoop];
    NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];
    NSLog(@"P mainRunLoop:%p---currentRunLoop:%p",mainRunLoop,currentRunLoop);

    //Core Foundation
    NSLog(@"%p",CFRunLoopGetMain());
    NSLog(@"%p",CFRunLoopGetCurrent());
    
    //从Cocoa的Runloop对象获得对应的 Core Foundation
    NSLog(@"%p",mainRunLoop.getCFRunLoop);
    
    
    //开启一条子线程并且获取打印对应的RunLoop
    [[[NSThread alloc]initWithTarget:self selector:@selector(getRunloopOfSubThread) object:nil] start];
    NSLog(@"getRunloopOfMainThread_Thread:%@",[NSThread currentThread]);
}

-(void)getRunloopOfSubThread {
    NSLog(@"getRunloopOfSubThread_Thread:%@",[NSThread currentThread]);
    NSLog(@"getRunloopOfSubThread:%@",[NSRunLoop currentRunLoop]);
}

@end

```
打印结果如图：

![有帮助的截图]({{ site.url }}/assets/postsImages/WechatIMG1.jpeg)

从打印结果可以看到主线程和子线程中获得的runloop对象不同，而且没用主动去创建Runloop，初步直觉有	
>每条线程都有唯一的一个与之对应的RunLoop对象.  

查看源码CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:

```oc

/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;
 
/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&loopsLock);
    
    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }
    
    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
    
    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }
    
    OSSpinLockUnLock(&loopsLock);
    return loop;
}
 
CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}
 
CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}

```

从上面的代码可以看出，线程和RunLoop之间确实是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。
>其中在打印子线程Runloop结果中发现RunLoop的一些关键属性:   
> current mode   
 common modes    
 common mode items,   
modes.  
>	sources0  
	sources1  
	observers  
	timers  




#### RunLoop 剖析 RunLoop对外的接口

##### 分析前面打印结果的内容
* `current mode`  每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode
* `modes` 一个 RunLoop包含若干个Mode,可以在多个mode中切换，但是每次运行只能在一个模式下
* `common mode items` 每个Mode又包含若干个source/timer/observer这些就是它的items
* `sources0  
	sources1  
	observers  
	timers` timers、sources0和sources1时触发RunLoop处理事件的源，observer对RunLoop生命周期和处理事件过程的观察。source，timer，observe都都对应的模式。

Runloop接收输入事件来自两种不同的来源:输入源(input source)和定时源 (timer source)。输入源传递异步事件，通常消息来自于其他线程或程序。定时源 则传递同步事件，发生在特定时间或者重复的时间间隔。两种源都使用程序的某一特 定的处理例程来处理到达的事件。下图显示了runloop的概念结构以及各种源。输入源传递异步消息给相应的 处理例程，并调用 runUntilDate:方法来退出(在线程里面相关的 NSRunLoop 对象调 用)。定时源则直接传递消息给处理例程，但并不会退出 runloop。	
![有帮助的截图]({{ site.url }}/assets/postsImages/runloop_structure.jpg)

在 CoreFoundation 里面关于 RunLoop 有5个类:

CFRunLoopRef  
CFRunLoopModeRef  
CFRunLoopSourceRef  
CFRunLoopTimerRef  
CFRunLoopObserverRef  

其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:

![有帮助的截图]({{ site.url }}/assets/postsImages/runloopcontent.jpg)

> 将上面的内容分开来看RunLoop中3个重要的概念为：源(source)、模式(mode)和观察者(observers)


#### RunLoop 的 Mode
CFRunLoopMode 和 CFRunLoop 的结构大致如下 

```oc
struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};
 
struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
```


每次运行你的runloop，你都要指定(无论显示还是隐式)其运行个模式，这个模式就是当前_currentMode(参考前面洗衣机的类比)。在runloop运行过程中，只有和模式相关的源才会被监视并允许他们传递事件消息。(类似的，只有和模式相关的观察者会通知runloop的进程)。和其他模式关联的源只有在runloop运行在其模式下才会运行，否则处于暂停状态。通常在你的代码中，你可以通过指定名字来标识模式。Cocoa 和 Core foundation 定义了一个默认的和一些常用的模式，在代码中都是用字符串来标识这些模式。 当然你也可以给模式名称指定一个字符串来自定义模式。虽然你可以给模式指定任意名字，但是模式的内容则不能是任意的。你必须添加一个或多个输入源，定时源或者runloop的观察者到你新建的模式中让他们有价值。通过指定模式可以使得 runloop 在某一阶段过滤来事件。大多数时候，runloop 都是运行在系统定义的默认模式上。下图列出了 Cocoa 和 Core Foundation 定义的标准模式，并且介绍何时使用他 们。名称那列列出了你用来在你代码中指定模式实际的常量。

![有帮助的截图]({{ site.url }}/assets/postsImages/runloop_source.png)

>说明一些上面系统默认注册了5个Mode:
>
1. kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行    
2. UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响
3. .UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用
4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到
5. kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode

> >“CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。
> > >主线程的RunLoop里有两个预置的Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性




#### commonmode的应用场景


DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。这里就验证了:
>在runloop运行过程中，只有和模式相关的源才会被监视并允许他们传递事件消息。(类似的，只有和模式相关的观察者会通知runloop的进程)。和其他模式关联的源只有在runloop运行在其模式下才会运行，否则处于暂停状态。通常在你的代码中，你可以通过指定名字来标识模式。

如果有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。



#### RunLoop 输入源

* `CFRunLoopSourceRef` 是事件产生的地方。Source有两个版本：Source0 和 Source1。
• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。
• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。

* `CFRunLoopTimerRef` 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。



#### RunLoop 观察者
源是合适的同步或异步事件发生时触发，而runloop 观察者则是在 runloop 本 身运行的特定时候触发。你可以使用 runloop 观察者来为处理某一特定事件或是进入休眠的线程做准备。

