---
layout:     post
title:      iOS中的多线程的基本概念与实践
subtitle:   多线程
date:       2017-08-31
author:     ALin
header-img: img/post-bg-swift.jpg
catalog: true
tags:
    - iOS
---


> 本文首次发布于 [linra](https://github.com/LinKeymy), 作者 [@onevlin](http://onevlin.com/) ,转载请保留原文链接.

#####Write the code. Change the world.

####一、进程和线程
#####进程

进程是一个实体，在 iOS中每一个运行的App对应一个进程，进程有三个状态：就绪，运行，阻塞.顺便提及程序，程序是指令和数据的有序集合，其本身没有任何运动的含义，是一个静态的概念，而进程则是在处理机上的一次执行过程，它是一个动态的概念。进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。

#####线程
通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位

#####多线程
在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。同一时间, CPU 只能处理一条线程,只有一条线程在工作.多线程并发(同时)执行, 其实是 CPU 快速地在多条线程之间调度.如果 CPU 调度线程的时间足够快,就造成了多线程并发执行的假象.


```oc
举个庶子，假设进程是一个工厂，在工厂运行效率不变的前提下，而线程就是工厂中的一条流水线，流水线上的工人所做的事情就对应“"程序片段"或者"任务单元",那么多线程就是多条流水线共享整一个工厂的资源来同步完成生产任务。但是一条流水线上的人任务是按照时序进行的。
```

####二、多线程在iOS开发中的应用

##### 耗时操作在主线程带来的问题

iOS中每个程序启动都会开一条线程来显示UI，处理UI事件如点击，滚动，手势等，这一条线程就是主线程。如果耗时的操作放在主线程会发生什么事情呢？一起来看看下面的两个例子.

```swift
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        textView.delegate = self
    }

    @IBAction func buttonClicked(_ sender: UIButton) {
        print("print begin\(Thread.current)")
        for _ in 0...100000 {
            print("我在打印中")
        }
        print("print end")
    }
    @IBOutlet weak var textView: UITextView!   
}

extension ViewController: UITextViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        print("scrollViewDidScroll")
    }
    
}
```

这样在点击button的后，“print end“没有打印出来，去滚动textView界面是没有响应的。待“print end“打印出来后才会去响应用户的滚动，这样的体验是极度不友好的。其实在控制台可以看到:
~~Todo~~

通过上面的demo可以知道
- [x] 监听按钮的方法是在主线程
- [x] 点击按钮后开始执行耗时操作
- [x] 不应该将耗时的操作放在主线程中执行，这会引起线程阻塞程序无 法处理UI的刷新和滚动等
######为了避免上面的主线程阻塞，需要将耗时操作放在子线程中执行。这就是接下来讨论的多线程

#### 三、多线程的实现方案

|         技术方案          |                    简介                    |    语言    | 线程生命周期 |
| :-------------------: | :--------------------------------------: | :------: | :----: |
|        pthread        | 通用的多线程,适用于Unix/Linux/Windwows等，跨平台可移植,属于比较底层的API，iOS开发中几乎不用 |    C     | 程序员管理  |
|    NSTread/Thread     |             面向对象，可以直接操作线程对象              | OC/Swift | 程序员管理  |
|          GCD          |       充分利用设备的多核，对于Swift面向对象，对C为函数        | C/Swift  |  自动管理  |
| NSOperation/Operation |      基于GCD，使用更加面向对象，也比GCD多些简单使用d的功能      | OC/Swift |  自动管理  |



#####使用pthread，解决刚才阻塞UI的问题
```swift

class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    @IBAction func buttonClicked(_ sender: UIButton) {
        print("funtion \(#function) perform in \(Thread.current)")
        pthreadDemo()
    }
    @IBOutlet weak var textView: UITextView!
    

}

// 在Swift中只有函数以及不捕获外部对象的闭包才能作为C函数指针的
//实参，类的成员方法、以及捕获外部对象的闭包都不能作为C函数指针的实参。
func printAction(arg: UnsafeMutableRawPointer) -> UnsafeMutableRawPointer?  {
    print("funtion \(#function) perform in \(Thread.current)")
    print("print begin")
    for _ in 0...100000 {
        print("我在打印中")
    }
    print("print end")
    return arg
}

extension ViewController {
    func pthreadDemo() {
        var thread: pthread_t? = nil
        pthread_create(&thread, nil, printAction, nil)
        pthread_cancel(thread!)
    }
}
```
我们在添加pthreadDemo函数，这里创建一条线程，并将打印的操作printAction放到该线程中执行，可以发现，在执行printAction里面的同时，滚动textView不受影响，问题得到解决。打印线程信息可以发现：`buttonClickedID`为1（number = 1为线程ID，且1为主线程）的线程中执行，`printAction(arg:)`ID为3的线程中执行

```c
funtion buttonClicked perform in <NSThread: 0x174078fc0>{number = 1, name = main}
funtion printAction(arg:) perform in <NSThread: 0x174268180>{number = 3, name = 
print begin
```
pthread在平时的iOS开发中几乎使用不到，这里也就不深入去探究了。对系统底层进程，线程感兴趣的朋友可以自己探索。
#####使用Thread，解决刚才阻塞UI的问题

```swift
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    @IBAction func buttonClicked(_ sender: UIButton) {
        print("funtion \(#function) perform in \(Thread.current)")
        threadDemo()
    }
}


extension ViewController {

    func threadDemo() {
        if #available(iOS 10.0, *) {
            Thread.detachNewThread {
                print("funtion \(#function) perform in \(Thread.current)")
                print("print begin")
                for _ in 0...100000 {
                    print("我在打印中")
                }
                print("print end")
            }
        }
    }
}

```
上面的代码执行效果和使用phread方案相同。也可以在控制台找到如下线程信息和函数的执行信息

```c
funtion buttonClicked perform in <NSThread: 0x170264600>{number = 1, name = main}
funtion threadDemo() perform in <NSThread: 0x1704645c0>{number = 3, name = (null)}
```

按住键盘command键，点击Thread，进入Thread的头文件查看属性和方法，可以看到几个重要的属性

    open class var current: Thread { get }  //获得当前线程
    open var name: String? // 线程名字，可以设置
    open var threadPriority: Double  // 线程优先级
    open var isMainThread: Bool { get } // 判读是否线程是否为主线程
    open class var main: Thread { get } // 获得主线程

同时Thread还有其他的init方法和detachNewThread方法

```swift
  @available(iOS 10.0, *)
 open class func detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?)
     @available(iOS 2.0, *)
    public convenience init(target: Any, selector: Selector, object argument: Any?)

    @available(iOS 10.0, *)
    public convenience init(block: @escaping () -> Swift.Void)
```
3> 创建3条线程同时执行，看打印结果
##### 其他创建线程的方式
在上面提到的NTThread.h中底部可以发现NSObject的一个扩展，它们也提供了操作线程的能力

```swift
extension NSObject {

    open func performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?)

    open func performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool)

    @available(iOS 2.0, *)
    open func perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?)

    @available(iOS 2.0, *)
    open func perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool)
    
    @available(iOS 2.0, *)
    open func performSelector(inBackground aSelector: Selector, with arg: Any?)
}
```


##### 线程的生命周期与状态：出生 -> 运行 -> 睡眠 -> 死亡
使用下面的方法创造线程需要程序员自己调用start方法，runNeedStard才会执行。

```oc
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(runNeedStard) object:nil];
[thread start];
```
上面的线程一旦创建便进入可调度线程池，可调度线程池装在执行的线程，而是表明池子里的线程具有被CPU调度的资格或者说能力。
CPU调度线程时，线程就进入到运行状态，执行相应的方法。

```swift
[thread sleep];
```
调用用sleep方法后，线程会被移出可调度线程池，进入休眠状态。线程处于休眠状态时是不会被CPU调用到的，当休眠的线程被唤醒时再次进入可调度线程池，线程才恢复了可调用。可以看出CPU会到可以调用线程池里面寻找线程就行调度。

```swift
[thread exit];
```
调用用exit方法后，线程会出从当前状态变成死亡状态。但是线程可能还没有背清理，也就是`尸体`还在,死亡状态的线程被移出可调度线程池，而且随后的状态不会改变。死亡的线程时不可能被唤醒也不会进入失眠状态，同时也一定无法运行。也就是线程死亡后调用 [thread sleep] [start] 等方法会产生问题，不信？你可以去试试。


###GCD(Grand Central Dispatch)

>GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。

在深入理解并使用 GCD 前，你应该先掌握下面的知识点：

DispatchQueue 是执行任务的强大工具，允许你同步或异步地执行任意代码block/closure。原先使用单独线程执行的所有任务都可以替换为使用DispatchQueue。 而DispatchQueue最大的优点在于使用简单，而且更加高效。我们使用函数或 block/closure 对象来定义任务，并添加到DispatchQueue。DispatchQueue是类似于对象的结构体，管理你提交给它的任务，而且都是 先进先出的数据结构。因此
| 类型 | 描述 |
| :-- | :-- |
| 串行队列 |  
<div>每次只执行一个任务，按任务添加顺序执行(FIFO)。当前正在执行的任务在独立的线程中运行(不同任务的线程可能不同)，Dispatch Queue 管理了这些线程。 通常串行 queue 主要用于对特定资源的同步访问（它比锁更轻量好用）。 你可以创建任意数量的串行 queues，虽然每个 queue 本身每次只能执行一个任务，但是各个 queue 之间是并发执行的</div>

 |
| 并发队列 |  
<div>可以并发执行一个或多个任务，任务仍然是以添加到 queue 的顺序启动（这里是开始执行的顺序，但是由于任务耗时以及其他因素，导致执行结果不一定按照 FIFO 的顺序呈现）。每个任务运行 于独立的线程中，Dispatch Queue 管理所有线程。同时运行的任务数量随时都会变化，而且依赖于系统条件。 你可以创建并发 Queues，但是笔者建议在开发中最好使用已经定义好的全局并发 queues</div>

 |
| 主队列 | 全局可用的串行 queue，在应用主线程中执行任务。这个 queue 与应用的 RunLoop 交叉执行，通常用于应用的关键同步点。 |
 queue 中的任务总是以添加的顺序开始执行。GCD提供了几种DispatchQueue。

> 
`DispatchQueue`的几个关键点:
`DispatchQueue` 相对其它 `DispatchQueue`并发地执行任务（不同的 queue 不相互影响），串行化任务只能在同一个 `DispatchQueue` 中实现。
系统决定了同时能够执行的任务数量，应用在 100 个不同的 queues 中启 动 100 个任务，并不表示 100 个任务全部都在并发地执行(除非系统拥有 100 或更多个核)。
系统在选择执行哪个任务时，会考虑 queue 的优先级。
queue 中的任务必须在任何时候都准备好运行，注意这点和后面要讲到的 Operation对象不同。

###未完待续，先给出基本的提纲和简介，有空再补充完善。

2> 任务、队列、同步、异步
任务：需要执行的操作
队列: 用来存放任务

GCD的使用步骤：1.首先定制需要执行的任务 2.将需要执行的任务添加到队列中
GCD会自动将队列中的任务取出，放到对应的线程中去执行，任务的取出顺序遵循队列的First In First Out的原则。

##### GCD有两种方式来执行任务：

1.使用同步的方式来执行任务

dispatch_sync(dispatch_queue_t queue,dispath_block_t block)

同步不具备开启新线程的能力

2.使用异步的方式来执行任务
dispatch_async(dispatch_queue_t queue,dispath_block_t block)
异步具备开启新线程的能力
queue:队列
block：添加到队列的任务

同步和异步决定了要不要开启新的线程
同步会在当前线程中执行任务，不具备开启新线程的能力（或者说没有开启线程的需求）
异步会在新的线程中执行任务，具备开启新线程的能力（或者说可能有开启新线程的需求）
同步和异步是用来描述当前函数是否需要等待其任务完成再往下执行。同步是需要等待，而异步不需要。
可以将队列看成一个数组，任务是添加到数组里面的元素。无论是同步还是异步的队列都是按顺序从数组(队列)中取出任务，只是同步函数需要任务执行完才区下一个任务去执行，而异步不需要等待，对于同步函数，从队列中取出任务将其当前线程去执行，待任务执行完毕才取下一个任务去执行(也就是重复上一步的循环)。对于异步函数，会取出一个任务将其放到空闲的线程中执行，如果没有空闲的线程，就开启新的一条线程(对于串行的队列只需要一条现场就满足)。无需等待任务结束，就取下一个任务。

####4> 常用函数

* once
* after
* group

七、单例模式
http://www.cnblogs.com/supercheng/archive/2012/11/26/singlemodal.html

八、NSOperation、NSOperationQueue
1> NSInvocationOperation
2> NSBlockOperation
3> NSOperationQueue
4> 自定义NSOperation


####线程通信 

  @一条线程将数据传递给另外一条线程

  @在一条现场执行任务时，转到另外一条线程
  
  dispatch_async(

dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

   // 执行耗时的异步操作...

   dispatch_async(dispatch_get_main_queue(), ^{

​       // 回到主线程，执行UI刷新操作

   });

});


#### 线程的资源抢夺 (多线程带来的问题，解释线程同步和使用)




