---
layout:     post
title:      iOS中的多线程的基本概念与实践
subtitle:   多线程
date:       2017-08-31
author:     ALin
header-img: img/post-bg-swift.jpg
catalog: true
tags:
    - iOS
---


> 本文首次发布于 [linra](https://github.com/LinKeymy), 作者 [@onevlin](http://onevlin.com/) ,转载请保留原文链接.

#### #Write the code. Change the world.

####一、进程和线程
#####进程

进程是一个实体，在 iOS中每一个运行的App对应一个进程，进程有三个状态：就绪，运行，阻塞.顺便提及程序，程序是指令和数据的有序集合，其本身没有任何运动的含义，是一个静态的概念，而进程则是在处理机上的一次执行过程，它是一个动态的概念。进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。

#####线程
通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位

#####多线程
在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。同一时间, CPU 只能处理一条线程,只有一条线程在工作.多线程并发(同时)执行, 其实是 CPU 快速地在多条线程之间调度.如果 CPU 调度线程的时间足够快,就造成了多线程并发执行的假象.


```oc
举个庶子，假设进程是一个工厂，在工厂运行效率不变的前提下，而线程就是工厂中的一条流水线，流水线上的工人所做的事情就对应“"程序片段"或者"任务单元",那么多线程就是多条流水线共享整一个工厂的资源来同步完成生产任务。但是一条流水线上的人任务是按照时序进行的。
```

####二、多线程在iOS开发中的应用

##### 耗时操作在主线程带来的问题

iOS中每个程序启动都会开一条线程来显示UI，处理UI事件如点击，滚动，手势等，这一条线程就是主线程。如果耗时的操作放在主线程会发生什么事情呢？一起来看看下面的两个例子.

```swfit
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        textView.delegate = self
    }

    @IBAction func buttonClicked(_ sender: UIButton) {
        print("print begin\(Thread.current)")
        for _ in 0...100000 {
            print("我在打印中")
        }
        print("print end")
    }
    @IBOutlet weak var textView: UITextView!   
}

extension ViewController: UITextViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        print("scrollViewDidScroll")
    }
    
}
```

这样在点击button的后，“print end“没有打印出来，去滚动textView界面是没有响应的。待“print end“打印出来后才会去响应用户的滚动，这样的体验是极度不友好的。其实在控制台可以看到:




* 说明监听按钮的方法是在主线程
* 点击按钮后开始执行耗时操作

  不应该将耗时的操作放在主线程中执行，这会引起线程阻塞程序无法处理UI的刷新和滚动等，将耗时操作放在子线程中执行可以避免主线程阻塞。


#### 三、多线程的实现方案

|         技术方案          |                    简介                    |    语言    | 线程生命周期 |
| :-------------------: | :--------------------------------------: | :------: | :----: |
|        pthread        | 通用的多线程,适用于Unix/Linux/Windwows等，跨平台可移植,属于比较底层的API，iOS开发中几乎不用 |    C     | 程序员管理  |
|    NSTread/Thread     |             面向对象，可以直接操作线程对象              | OC/Swift | 程序员管理  |
|          GCD          |       充分利用设备的多核，对于Swift面向对象，对C为函数        | C/Swift  |  自动管理  |
| NSOperation/Operation |      基于GCD，使用更加面向对象，也比GCD多些简单使用d的功能      | OC/Swift |  自动管理  |



2> 简单演示pthread，解决刚才阻塞UI的问题

五、NSThread
1> 利用NSThread解决阻塞UI的问题
2> 演示mainThread、currentThread方法、name属性、threadPriority优先级属性
3> 创建3条线程同时执行，看打印结果
4> 其他创建线程的方式

5> 线程的状态

6>NSThread 常见用法

1> 开线程的几种方式

\* 先创建,后启动

NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(runNeeeStard) object:nil];

[thread start];

\* 直接启动

[NSThread detachNewThreadSelector:@selector(runAuto) toTarget:self withObject:nil];

[self performSelectorInBackground:@selector(runAuto2) withObject:nil];

2> 其他用法

NSThread *current = [NSThread currentThread];

\+ (NSThread *)mainThread;

3> 线程间通信

performSelectorOnMainThread.....

* 出生 -> 运行 -> 睡眠 -> 死亡

* 演示exit、sleep方法
  6> 线程的资源抢夺

  7> 线程通信

  具体体现

  @一条线程将数据传递给另外一条线程

  @在一条现场执行任务时，转到另外一条线程

  常用的方法有

  performSelector起头的

六、GCD
1> 基本概念
2> 任务、队列、同步、异步

任务：需要执行的操作

队列: 用来存放任务

GCD的使用步骤：1.首先定制需要执行的任务 2.将需要执行的任务添加到队列中

GCD会自动将队列中的任务取出，放到对应的线程中去执行，任务的取出顺序遵循队列的First In First Out的原则。

##### GCD有两种方式来执行任务：

1.使用同步的方式来执行任务

dispatch_sync(dispatch_queue_t queue,dispath_block_t block)

同步不具备开启新线程的能力

2.使用异步的方式来执行任务

dispatch_async(dispatch_queue_t queue,dispath_block_t block)

异步具备开启新线程的能力

queue:队列

block：添加到队列的任务

##### CGD队列的两种类型

1.并发队列：可以让多个任务并发(同时)执行（按FIFO顺序取出任务根据需要自动开启新的线程去执行任务）,并发功能只有在异步的函数下(dispatch_async)才有效。CGD的并发队列只有全局队列，通过dispatch_get_global_queue 来获得。

2.串行队列：

让任务顺序一个接着一个的执行（一个任务执行完毕后才执行下一个任务），串行队列有两种方式获得.

a.自己创建队列： dispatch_queue_create

b.获取主队列：dispatch_get_main_queue



综上：

同步和异步决定了要不要开启新的线程

同步会在当前线程中执行任务，不具备开启新线程的能力（或者说没有开启线程的需求）

异步会在新的线程中执行任务，具备开启新线程的能力（或者说可能有开启新线程的需求）

同步和异步是用来描述当前函数是否需要等待其任务完成再往下执行。同步是需要等待，而异步不需要。

可以将队列看成一个数组，任务是添加到数组里面的元素。无论是同步还是异步的队列都是按顺序从数组(队列)中取出任务，只是同步函数需要任务执行完才区下一个任务去执行，而异步不需要等待，对于同步函数，从队列中取出任务将其当前线程去执行，待任务执行完毕才取下一个任务去执行(也就是重复上一步的循环)。对于异步函数，会取出一个任务将其放到空闲的线程中执行，如果没有空闲的线程，就开启新的一条线程(对于串行的队列只需要一条现场就满足)。无需等待任务结束，就取下一个任务。

3> 线程间通信

dispatch_async(

dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

   // 执行耗时的异步操作...

   dispatch_async(dispatch_get_main_queue(), ^{

​       // 回到主线程，执行UI刷新操作

   });

});

4> 常用函数

* once
* after
* group

七、单例模式
http://www.cnblogs.com/supercheng/archive/2012/11/26/singlemodal.html

八、NSOperation、NSOperationQueue
1> NSInvocationOperation
2> NSBlockOperation
3> NSOperationQueue
4> 自定义NSOperation


